# SAFE_CALL

This simple library allows you to protect yourself against reverse engineers.
It works on x86 and x64 and is meant for calls to the dotnet-framework as seen in the usage-example below.

Usage:
``` cs
//static method
_.SAFE_CALL(typeof(Console), "WriteLine", "Hello World!");

//instance method
_.SAFE_CALL(webClientInstance, typeof(WebClient), "DownloadString", "https://pastebin.com/raw/fBqd8yM6");
```
<br/>

NOTE: It works best with static methods. Instances can cause issues.
      If you encounter any issue with shadowcopy you can disable it globally using:
``` cs 
_.bCreateShadowCopies = false;
```
<br/>

Internals of what the library does:
1. Check if the function you are trying to call is hooked
2. Check if IsDebuggerPresent is hooked and also check what it returns.
3. Create a DynamicMethod and copy over the il code generated by the disassembler (shadow-copy).
4. Invoke the new shadow-copy and return its output.

#### ShadowCopy:
Creating a shadow-copy will prevent reversers from 
placing a breakpoint on the function you are trying to call 
and makes it hard to follow the program-flow.

#### NOTE:
This whole library can be merged into a single .cs file so it does not have to be an external dependency.
Just add it to your project and you are good to go.

This project could also be modified to throw a custom exception, when a call is unsafe or fails.
The developer could then catch the exception and do what they want to. For example: (close the app, report violation, etc.)
